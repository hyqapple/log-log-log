# 在浏览器输入 URL 回车之后发生了什么

## 大致流程

- URL 解析
- DNS 查询
- TCP 连接
- 处理请求
- 接受响应
- 渲染页面

## 一、URL 解析

- 首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。
- 浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。

## 二、DNS 查询

| #   | 查询流程         | 解释                                                                                                              |
| --- | ---------------- | ----------------------------------------------------------------------------------------------------------------- |
| 1   | 浏览器缓存       | 浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询                                                          |
| 2   | 操作系统缓存     | 操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求 |
| 3   | 路由器缓存       | 路由器也有自己的缓存                                                                                              |
| 4   | ISP DNS 缓存     | ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存                                     |
| 5   | 根域名服务器查询 | 在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域                                       |

## 三、TCP 连接

TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装

### 应用层：发送 HTTP 请求

在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括

- 请求报头（Request Header）：请求方法、目标地址、遵循的协议等等
- 请求主体（其他参数）

### 传输层：TCP 传输报文

传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。

在建立连接前，会先进行 TCP 三次握手。

#### 三次握手 ヽ(_^ｰ^)人(^ｰ^_)ノ

为什么会采用三次握手，若采用二次握手可以吗？ 四次呢？

建立连接的过程是利用客户服务器模式，假设主机 A 为客户端，主机 B 为服务器端。
采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 B，因而产生错误。失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。
采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。而在三次握手中， client 和 server 都有一个发 syn 和收 ack 的过程， 双方都是发后能收， 表明通信则准备工作 OK.
为什么不是四次握手呢？ 大家应该知道通信中著名的蓝军红军约定， 这个例子说明， 通信不可能 100%可靠， 而上面的三次握手已经做好了通信的准备工作， 再增加握手， 并不能显著提高可靠性， 而且也没有必要。

### 网络层：IP 协议查询 Mac 地址

将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。

判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。

### 链路层：以太网协议

#### 以太网协议

根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：

- 标头：数据包的发送者、接受者、数据类型
- 数据：数据包具体内容

#### Mac 地址

以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。

### 服务器接受请求

接受过程就是把以上步骤逆转过来

## 四、服务器处理请求

处理端口请求的数据。匹配路径。

### HTTPD

## 五、浏览器接受相应

浏览器接收到来自服务器的响应资源后，会对资源进行分析。
首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。
如果响应资源进行了压缩（比如 gzip），还需要进行解压。
然后，对响应资源做缓存。
接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。

## 六、渲染页面

解析 —— HTML，CSS，JS
渲染 —— 构建 DOM 树 -> 渲染 -> 布局 -> 绘制

### 1 HTML 解析

| 过程                        | 详解                                                                                                                                                          |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 解码（encoding）            | 传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。                                                |
| 预解析（pre-parsing）       | 预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如 img 标签的 src 属性，并将这个请求加到请求队列中。                              |
| 符号化（Tokenization）      | 符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。它通过一个状态机去识别符号的状态，比如遇到<，>状态都会产生变化。 |
| 构建树（tree construction） | 符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。                                                                           |

当整个解析的过程完成以后，浏览器会通过 DOMContentLoaded 事件来通知 DOM 解析完成。

### 2 CSS 解析

一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。

### 3 渲染树

其实这就是一个 DOM 树和 CSS 规则树合并的过程。

#### 渲染阻塞

- CSS 会阻塞 JS 执行
- JS 会阻塞后面的 DOM 解析

#### 计算

- 通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把 rem 转化为 px。

### 4 布局与绘制

确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。
然后遍历渲染树，调用渲染器的 `paint()` 方法在屏幕上显示其内容。

### 5 合并渲染层

把以上绘制的所有图片合并，最终输出一张图片。

### 6 回流与重绘

#### 回流(reflow)

当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从 html 标签开始递归往下，重新计算位置和大小。

reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。

#### 重绘(repaint)

改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。

每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。

回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。

`display:none 会触发回流，而 visibility:hidden 只会触发重绘。`

### 7 JavaScript 编译执行

#### 词法分析

JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。

#### 预编译

JS 有三种运行环境：

- 全局环境
- 函数环境
- eval

每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。
创建执行上下文的过程中，主要做了以下三件事：

- 创建变量对象
  - 参数、函数、变量
- 建立作用域链
  - 确认当前执行环境是否能访问变量
- 确定 This 指向

#### 执行

- JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎
- 事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行
- 定时器触发线程：主要控制 setInterval 和 setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。
- HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。

## links

- [在浏览器输入 URL 回车之后发生了什么](https://juejin.im/post/5d5e795ff265da03e275f29e)
- [前端经典面试题: 从输入 URL 到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)
- [What-happens-when 的中文翻译](https://github.com/skyline75489/what-happens-when-zh_CN)
- [浏览器输入 URL 后发生了什么？](https://zhuanlan.zhihu.com/p/43369093)
